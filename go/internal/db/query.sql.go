// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChatgptMessage = `-- name: CreateChatgptMessage :one
INSERT INTO chatgpt_messages (
    id, message_type, json_body, user_name, mastodon_status_id
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, message_type, json_body, user_name, mastodon_status_id, created_at, updated_at
`

type CreateChatgptMessageParams struct {
	ID               uuid.UUID
	MessageType      string
	JsonBody         []byte
	UserName         string
	MastodonStatusID pgtype.Text
}

func (q *Queries) CreateChatgptMessage(ctx context.Context, arg CreateChatgptMessageParams) (ChatgptMessage, error) {
	row := q.db.QueryRow(ctx, createChatgptMessage,
		arg.ID,
		arg.MessageType,
		arg.JsonBody,
		arg.UserName,
		arg.MastodonStatusID,
	)
	var i ChatgptMessage
	err := row.Scan(
		&i.ID,
		&i.MessageType,
		&i.JsonBody,
		&i.UserName,
		&i.MastodonStatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChatgptThread = `-- name: CreateChatgptThread :one
INSERT INTO chatgpt_threads (id) VALUES ($1)
RETURNING id, created_at, updated_at
`

func (q *Queries) CreateChatgptThread(ctx context.Context, id uuid.UUID) (ChatgptThread, error) {
	row := q.db.QueryRow(ctx, createChatgptThread, id)
	var i ChatgptThread
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createChatgptThreadRel = `-- name: CreateChatgptThreadRel :exec
INSERT INTO chatgpt_threads_rel (
    thread_id, chatgpt_message_id, sequence_num
) VALUES ($1, $2, $3)
`

type CreateChatgptThreadRelParams struct {
	ThreadID         uuid.UUID
	ChatgptMessageID uuid.UUID
	SequenceNum      int32
}

func (q *Queries) CreateChatgptThreadRel(ctx context.Context, arg CreateChatgptThreadRelParams) error {
	_, err := q.db.Exec(ctx, createChatgptThreadRel, arg.ThreadID, arg.ChatgptMessageID, arg.SequenceNum)
	return err
}

const findChatgptMessageByMastodonStatusId = `-- name: FindChatgptMessageByMastodonStatusId :one
SELECT id, message_type, json_body, user_name, mastodon_status_id, created_at, updated_at
FROM chatgpt_messages
WHERE mastodon_status_id = $1
`

func (q *Queries) FindChatgptMessageByMastodonStatusId(ctx context.Context, mastodonStatusID pgtype.Text) (ChatgptMessage, error) {
	row := q.db.QueryRow(ctx, findChatgptMessageByMastodonStatusId, mastodonStatusID)
	var i ChatgptMessage
	err := row.Scan(
		&i.ID,
		&i.MessageType,
		&i.JsonBody,
		&i.UserName,
		&i.MastodonStatusID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatgptMessagesByThreadId = `-- name: GetChatgptMessagesByThreadId :many
SELECT
    json_body,
    user_name
FROM chatgpt_messages
INNER JOIN chatgpt_threads_rel ON chatgpt_messages.id = chatgpt_threads_rel.chatgpt_message_id
WHERE chatgpt_threads_rel.thread_id = $1
AND message_type != 'pseudo_message'
ORDER BY chatgpt_threads_rel.sequence_num
`

type GetChatgptMessagesByThreadIdRow struct {
	JsonBody []byte
	UserName string
}

func (q *Queries) GetChatgptMessagesByThreadId(ctx context.Context, threadID uuid.UUID) ([]GetChatgptMessagesByThreadIdRow, error) {
	rows, err := q.db.Query(ctx, getChatgptMessagesByThreadId, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatgptMessagesByThreadIdRow
	for rows.Next() {
		var i GetChatgptMessagesByThreadIdRow
		if err := rows.Scan(&i.JsonBody, &i.UserName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatgptThreadRels = `-- name: GetChatgptThreadRels :many
SELECT thread_id, chatgpt_message_id, sequence_num, created_at, updated_at
FROM chatgpt_threads_rel
WHERE thread_id IN (SELECT DISTINCT thread_id FROM chatgpt_threads_rel WHERE chatgpt_threads_rel.chatgpt_message_id = $1)
ORDER BY thread_id, sequence_num
`

func (q *Queries) GetChatgptThreadRels(ctx context.Context, chatgptMessageID uuid.UUID) ([]ChatgptThreadsRel, error) {
	rows, err := q.db.Query(ctx, getChatgptThreadRels, chatgptMessageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatgptThreadsRel
	for rows.Next() {
		var i ChatgptThreadsRel
		if err := rows.Scan(
			&i.ThreadID,
			&i.ChatgptMessageID,
			&i.SequenceNum,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxSequenceNum = `-- name: GetMaxSequenceNum :one
SELECT COALESCE(MAX(sequence_num), 0)::INT AS max_sequence_num
FROM chatgpt_threads_rel
WHERE thread_id = $1
`

func (q *Queries) GetMaxSequenceNum(ctx context.Context, threadID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getMaxSequenceNum, threadID)
	var max_sequence_num int32
	err := row.Scan(&max_sequence_num)
	return max_sequence_num, err
}
